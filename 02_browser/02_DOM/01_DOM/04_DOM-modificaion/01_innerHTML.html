<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>01_innerHTML</title>
</head>
<body>
    <h1>01. innerHTMl</h1>
    <pre>
        Element.prototype.innerHTML 프로퍼티는 setter와 getter 모두 존재하는 접근자 프로퍼티로
        요소 노드의 HTML마크업을 취득하거나 변경한다.
        textContent 프로퍼티는 HTML마크업을 무시하고  텍스트만 반환하지만 innerHTML 프로퍼티는 HTML마크업이
        포함된 문자열을 그대로 반환
    </pre>

    <div id="area">태그 앨리먼트의 값을 읽거나, 변경할 때 <span>innerHTML</span>속성을 사용한다.</div>

    <script>
        const $area = document.getElementById('area');

        console.log($area.innerHTML);
        
        $area.innerHTML += '값추가';

        $area.innerHTML += '<h1> innerHTML</h1>속성으로 값 변경';
    
        $area.innerHTML = '';
    </script>
    <pre>
        innerHTML 프로퍼티를 사용한 DOM조직은 구현이 간단하고 직관적이라는 장점이 있다.
        하지만 사용자로부터 입력받은 데이터를 그대로 innerHTML 프로퍼티에 할당하는 것은 위험하다는 단점도 있다.
        HTML마크업 내에 자바스크립트 악성코드가 포함되어 있따면 파싱 과정에서 그대로 실행될가능성이 있다.
    </pre>

    <script>
        // $area.innerHTML = `<img src='x' onerror='alert("메롱메롱~")'>`;
    </script>

    <!-- XSS문제를 해결하기 위한 HTML세니티제이션 -->
    <pre>
        innerHTMl 프로퍼티에 HTML마크업 문자열을 할당하는 경우 요소 노드의 모든 자식 노드를 제고하고
        할당한 HTML마크업 문자열을 파싱하여 DOM을 변경한다는 단점이 있다.
        또한 새로운 요소를 삽입할 때 위치를 지정할 수 없다는 단점도 있다.
    </pre>

    <ul id="list">
        <li class="coffee">커피</li>
    </ul>
    
    <script>
        const $list = document.getElementById('list');

        $list.innerHTML += `<li class='coke'>콜라</li>`
        //커피와 콜라 사이에 새로운 요소를 삽입하고 싶을 경우 ineerHTML을 통해서는 삽입위치를 지정할 수 없다.
        //기존 요소를 제거하지 않으면서 위치를 지정해 새로운 요소를 삽입해야할 때는 inserAdjacent가 더 효율 적

    </script>

</body>
</html>